# 概要介绍
- 通过`golang`的`选项模式`初始化`redis`客户端，选项模式可以灵活地使用选项模式来配置结构体，使得代码更加清晰和易于维护。
- go-redis/v9 发布订阅模式
- Redis Stream 模式
- 
## 选项模式优势
- 选项模式的适用于可动态添加初始化参数的结构体
- 避免长参数列表：当一个构造函数或方法需要很多参数时，传递这些参数会变得很不便且容易出错。长参数列表会使代码难以阅读和维护。选项模式通过将这些参数封装在配置结构体中，或者使用函数式选项，简化了参数传递。
- 提供灵活的配置方式：选项模式允许调用者仅设置他们关心的参数，而不需要提供所有参数
- 提供默认值：选项模式允许在构造函数中设置合理的默认值。调用者可以选择接受默认值，也可以根据需要覆盖这些默认值。这减少了代码中对默认值的重复定义。
- 提高代码的可维护性和可扩展性：当需要添加新的配置选项时，选项模式使得修改代码变得更容易。你可以添加新的选项函数，而不会影响现有的调用者。
- 提高代码的可读性：使用选项模式可以使代码更加简洁和可读，尤其是在构造对象时。选项的名称可以直接反映参数的含义，避免了长参数列表带来的混淆
- 提供参数验证：选项模式允许在设置参数时进行验证，确保传入的参数有效。这可以提高代码的健壮性，减少错误发生的可能性。

## redis 发布订阅模式_不支持消息持久化
在使用 Redis 进行消息发布和订阅时，如果没有消费者订阅消息，消息将不会被持久化或存储。这意味着，如果发布者发布了一条消息，但在发布消息的瞬间没有任何消费者订阅这个频道，这条消息将会丢失
Redis Pub/Sub 机制。
简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。
Redis 的发布/订阅（Pub/Sub）模式是一种消息传递模型，其中发布者（Publisher）将消息发布到频道（Channel），订阅者（Subscriber）订阅频道并接收消息。在这个模型中，消息的生命周期如下：
- 订阅: 消费者通过 SUBSCRIBE 命令订阅一个或多个频道。
- 发布: 发布者通过 PUBLISH 命令向一个或多个频道发布消息。
- 消息传递: 只有当消息发布时有订阅者订阅该频道，消息才会被传递到订阅者。
- 消息添加进队列后即使ack确认还是会保留数据，只是不会被其他消费者消费，消息如果不删除会继续存在缓存中，只有删除后当才不会重复处理，否则当前消费者for循环将会一直读取到

## redis Stream_支持消息持久化
Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。
Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。

## go-redis/v9 健康检查机制
    代码文件位置：github.com\redis\go-redis\v9@v9.6.1\pubsub.go
```
func (c *channel) initHealthCheck() {
ctx := context.TODO()//创建一个上下文 ctx，在此上下文中执行健康检查
c.ping = make(chan struct{}, 1)//初始化一个容量为 1 的 ping 通道，用于接收外部的健康检查信号。
	//启动一个新的 goroutine 进行健康检查
	go func() {
		//创建一个定时器 timer，初始设置为 1 分钟，但立即停止它，以便稍后重用
		timer := time.NewTimer(time.Minute) 
		timer.Stop()

		//进入一个无限循环，每次循环开始时重置定时器 timer，间隔时间为 c.checkInterval（健康检查间隔时间）
		for {
			timer.Reset(c.checkInterval)
			select {
			case <-c.ping:
				//处理健康检查信号: 当收到 ping 信号时，停止定时器。如果停止失败（可能是因为定时器已经超时），则消费定时器通道中的值，确保定时器处于停止状态
				if !timer.Stop() {
					<-timer.C
				}
			case <-timer.C:
				//定时器超时处理，定时器超时后发送ping的命令给服务端，如果失败则重连
				//当定时器超时时，调用 c.pubSub.Ping(ctx) 进行健康检查（给服务端发送ping的信息）。如果 Ping 方法返回错误，表示连接可能断开。
				//锁定 c.pubSub 的互斥锁，调用 c.pubSub.reconnect(ctx, pingErr) 尝试重连，然后解锁。
				if pingErr := c.pubSub.Ping(ctx); pingErr != nil {
					c.pubSub.mu.Lock()
					c.pubSub.reconnect(ctx, pingErr)
					c.pubSub.mu.Unlock()
				}
			case <-c.pubSub.exit:
				//当接收到 exit 信号时，退出 goroutine，停止健康检查。
				return
			}
		}
	}()
}
```