# map 引用类型
```go
// Map 是引用类型，函数或方法间传递，在函数或方法中进行新增或修改会影响原始数据
func TestMapEdit(t *testing.T) {
    data := make(map[string]any, 1)
    data["name"] = "LiXianPei"
    setMap(data, "age", 19)
    setMap(data, "phone", "123456")
    setMap(data, "summary", "这里是简介信息...")
    
    fmt.Println(data)
    //Output:
    //map[age:19 name:LiXianPei phone:123456 summary:这里是简介信息...]
}

func setMap(c map[string]any, key string, data any) {
    c[key] = data
}
```

# slice 切片的特殊情况
```go

// 切片作为函数的参数传递是 按值传递，切片内的数据是源数组的地址，因此当切片容量没有发生扩容时修改数据会影响源数据
// 切片在函数内使用append增加元素不会影响原切片，若发生cap扩容则切片地址发生变化，会生成一个新的切片
func TestSliceEdit(t *testing.T) {
	data := make([]int, 0, 1) //cap=1 容量大小决定了切片是否会发生扩容
	data = append(data, 1)
	fmt.Printf("元素地址：%p\n", data)

	editSlice(data)
	fmt.Println("元素修改后：", data) //此时数据已经发生了变更：[10]
}

// 切片作为值传递，但是切片指向的数组还是原来数组的地址，因此数组发生改变后会影响原数组的数据
func editSlice(items []int) {
	//若此时 append 增加的元素让切片扩容后 items 的地址发生变化，则 items 是新的地址，下面的修改则不会影响原数据
	//若此时 append 增加的元素没有让切片扩容，则 items 的修改会影响原数据，但是 append 的新元素不会出现在原数据中，可理解为两个切片只是共享元素地址信息
	items = append(items, 3, 4)
	for i := 0; i < len(items); i++ {
		items[i] = items[i] * 10
	}
	fmt.Printf("editSlice:%v,元素地址: %p\n", items, items)
}

```
# slice 扩容机制
代码中的关键点
- 双倍扩容：最常见的切片扩容方式是将容量加倍，这样可以减少切片的扩容次数。
- 阈值机制：为了平衡性能和内存使用，容量小于256时直接加倍，大于等于256时使用逐步增长的方式。
- 防止溢出：在计算新容量时，检查是否发生溢出，如果溢出，则直接设置为所需容量
```go
func growslice(et *_type, old slice, cap int) slice {
   //  ......
	newcap := old.cap
	doublecap := newcap + newcap    //双倍扩容（原容量的两倍）
	if cap > doublecap {   //如果所需容量大于 两倍扩容，则直接扩容到所需容量
		newcap = cap
	} else {
		const threshold = 256   //这里设置了一个 阈值 -- 256
		if old.cap < threshold {		//如果旧容量 小于 256，则两倍扩容
			newcap = doublecap   
		} else {
	    // 检查 0 < newcap 以检测溢出并防止无限循环。
			for 0 < newcap && newcap < cap {   //如果新容量 > 0  并且 原容量 小于 所需容量

               // 从小片的增长2x过渡到大片的增长1.25x。这个公式给出了两者之间的平滑过渡。(这里的系数会随着容量的大小发生变化，从2.0到无线接近1.25)
				newcap += (newcap + 3*threshold) / 4
              
                
              //当newcap计算溢出时，将newcap设置为请求的上限。
			if newcap <= 0 {   // 如果发生了溢出，将新容量设置为请求的容量大小
				newcap = cap
			}
		}
	}
}

```

# 溢出
在 Go 语言中，溢出是指计算结果超出了数据类型所能表示的范围。以下是几个常见数据类型的溢出例子，包括 int8, int16, int32, int64, 以及 uint 类型的溢出情况。

|类型| 长度（字节） | 默认值 | 说明                                 |
|:---|:---:|:---:|:---|
|byte| 1      | 0   | uint8                              |
|rune| 4      | 0   | Unicode Code Point, int32          |
|int, uint| 4或8    | 0   | 32 或 64 位                          |
|int8, uint8| 1      | 0   | -128 ~ 127, 0 ~ 255，byte是uint8 的别名 |
|int16, uint16| 2      | 0   |     -32768 ~ 32767, 0 ~ 65535                               |
|int32, uint32| 4      | 0   |        -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名                            |
|int64, uint64| 8      | 0|                                    |

```go
func TestOver(t *testing.T) {
	var x uint8 = 255 // uint8范围[0-255]
	x = x + 1         // 溢出
	fmt.Println(x)    // 输出 0

	var y int8 = 127 //int8-范围[-128,127]
	y = y + 1        //溢出
	fmt.Println(y)   //output: -128
}

```

# chan 通道
- 对一个关闭的通道再发送值就会导致panic
- 对一个关闭的通道进行接收会一直获取值直到通道为空
- 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值
- 关闭一个已经关闭的通道会导致panic

# 数据类型对比
- 布尔 是 不能与nil比较
- 整型 是 不能与nil比较
- 浮点数 是 不能与nil比较
- 复数 是 不能与nil比较
- 字符串 是 不能与nil比较
- 指针值 是 两个指针指向同一个变量，则这两个指针相等，或者两个指针同为nil，它们也相等。指针值可以与nil比较。
- 通道值 是 两个通道是由同一个make创建的，或者两个通道值都为nil，那么它们是相等，不同类型的通道都是nil也不可比较
- 接口值 是 如果两个接口值的动态值和动态类型都相等，或者两个接口值都为nil，那么它们是相等的。接口值可以与nil进行比较。
- struct 是/否 如果struct中所有的字段都是可比较的，那么两个struct是可比较的。如果struct对应的非空白字段相等，则它们相等。struct不能与nil比较，结构体字段顺序不一致也不能比较（编译错误）
- 数组 是/否 如果数组中的元素类型是可比的，则数组也是可比较的。如果数组中对应的元素都相等元素顺序必须一样，那么两个数组是相等的。数组不能与nil比较
- map 否 只能与nil比较
- slice 否 只能与nil比较
- func 否 只能与nil比较